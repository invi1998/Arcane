

# GameUI 概述

所以我们的游戏项目涉及到诸如健康等属性，在几乎所有的游戏项目中，健康和其他重要属性会显示在玩家的屏幕上。我们将在屏幕上显示的对象称为小部件。在虚幻引擎中，我们创建小部件蓝图来提供游戏数据的可视化表示。小部件蓝图是从基础的 C++ 类派生而来，您需要使用小部件蓝图来接收数据。

生命条需要知道要显示多少生命值。 给定技能的图标需要显示该技能的正确图标。 关键是小部件对象必须接收数据，以便它们知道要描绘的正确值和游戏中充斥着这些数据。. 游戏中充斥着这些数据。属性集包含给定角色所有属性的数值数据。

小部件对象可以直接访问游戏的数据结构，玩家状态出于各种原因可能包含一些需要在屏幕上向玩家显示的变量。游戏中有许多类，每个类都包含数据，这些数据可能需要或不需要由小部件对象知道，以便在游戏背后以数学方式向玩家展示发生的情况或者它可以使用更间接的方法，例如查询游戏的状态或订阅事件。

所以问题是小部件对象应该如何获取这些数据？

小部件对象可以通过多种方式深入游戏代码，无论使用哪种方法，小部件对象都需要访问必要的数据以执行其计算。 检索指向角色控制器、玩家状态、能力系统组件、属性集的指针和引用，并直接访问所有所需的数据属性集和访问所有所需的数据。

但这是最好的方式吗？ 在制作游戏项目时，你应该思考一个问题：随着游戏规模和复杂性的增长，应该如何设计这种类型的系统？当这种类型的数据出现时，应该如何处理？一个有经验的开发者会如何处理？三 A 级游戏是如何处理的？

如何以可扩展和可维护的方式完成这个任务。

现在，在一个良好结构化的程序中，我们应该通过用户界面有关注点的分离。

我们有三个不同的领域。

第一个领域是数据的视觉效果展示，例如生命条和能力图标。基本上所有的小部件，我们将这个领域称为视图，因为它包含了玩家在游戏中所看到的所有东西。在玩游戏时，这是玩家所看到的。

现在我们还有数据本身。这些是数值，玩家的生命值，玩家的等级，法力经验。已解锁的能力，它们的等级以及这些能力所分配的按钮。 所有这些数据都存在于游戏项目本身的代码库中，我们将这些数据称为 模型，它模拟了游戏的基本规则和结果。 这些数据最终将驱动我们在视图领域中看到的小部件。

现在，将数据从模型传递到视图是我们需要考虑的任务。

这可以通过多种方式完成，但是一个好的组织方式是拥有某种类型的类，可以处理从模型中检索数据并将其广播到视图的类。这个类不仅可以负责检索数据，还可以处理与处理数据相关的任何计算或算法功能。这个类存在于我们在这个系统中称之为控制器的领域中，控制器将负责从模型中检索数据并将其传递给视图，以便以可视化方式呈现数据。

现在我们不谈论引擎中的控制器或播放器控制器类。

这些类被设计用于拥有和控制角色，也就是我们所说的是用于驱动数据到视图的控制器类。 因此，出于这个原因，我们将其称为小部件控制器。这意味着视图只需关注数据应该如何从任何广播中接收，而不需要关注由控制器生成的数据本身。 但是视图可能包含玩家可以与之交互的小部件，例如按钮。当玩家点击按钮时，该操作可能导致模型发生一些变化，例如增加属性或为玩家授予新的能力。

所以控制器的工作也是通过小部件交互引起的操作，通过中介模式来促进这些操作玩家导致模型发生变化。换句话说，控制器是视图和模型之间的中间人。

现在，这种软件架构模式的实现有时会有所不同。有时，小部件控制器只负责从模型中检索数据并呈现，将其显示到视图中。 但是对于我们的项目，小部件控制器将承担更多的责任，它将处理按钮按下和播放器提供的信息，并发送信号给模型。因此，模型可以通过模型视图控制器架构进行更改，我们有三个独立的关注点并且每个域都与其他域隔离开来。这使得系统高度模块化。它防止我们将依赖硬编码到系统中，从而使系统变得僵化。

我们的模型不应该关心用于表示其数据的控制器或小部件。控制器本身依赖于模型中的类。 控制器不应该知道哪些小部件正在接收广播给它们的数据。小部件依赖于控制器。 如果我们保持这些单向依赖关系，那么模型可以将其小部件控制器更改为其他小部件控制器，而无需更改模型中的任何代码，从而可以为其他小部件控制器提供输出。

同样地，控制器不需要知道系统中有哪些类型的小部件，因为它是依赖于控制器的小部件。这样，控制器也可以更换它们的小部件，而无需更改任何控制器代码 。

现在，我们拥有一个灵活且编码良好的代码库。这就是我们将为这个游戏项目设计的系统类型，随着我们的项目变得越来越复杂我们将看到这样一个系统的好处。

我们的控制器可以是一个简单的对象，我们将赋予它从系统中收集数据并将其广播到小部件的能力。我们将创建一个用户小部件的子类，该子类与我们的小部件控制器类兼容。 

![image-20240406133443923](.\image-20240406133443923.png)