对于敌人的动画蓝图，因为该项目里有多种类型的敌人，他们的骨骼结构是不一样的， 为了使其更加通用并防止重复代码，我们的敌人动画蓝图将使用一个模板动画蓝图。

![image-20240405131231890](.\image-20240405131231890.png)

设置状态机

![image-20240405131341682](.\image-20240405131341682.png)

然后再状态机中，使用混合空间来输出动画

![image-20240405131631997](.\image-20240405131631997.png)

这里我们需要两个变量来驱动

![image-20240405131831984](.\image-20240405131831984.png)

然后在后续具体的怪物动画蓝图中，我就只需要更改资产覆盖，就能实现动画蓝图的复用



## UE5蓝图项目和C++项目，这两个打包后的运行效率谁更高

UE5蓝图项目和C++项目的打包后的运行效率并不能简单地说哪一个更高。运行效率受到多种因素的影响，包括但不限于：

1. **逻辑实现**：
   - 如果蓝图项目和C++项目中的逻辑实现相同，理论上C++代码的执行效率可能稍高，因为C++代码是直接编译为机器码执行的，而蓝图需要在运行时通过虚幻引擎的蓝图虚拟机（VM）解释执行。
   - 但是，虚幻引擎对蓝图做了大量的优化，大部分情况下蓝图的性能损失可能并不显著，除非存在大量循环、递归或过于复杂的蓝图逻辑。

2. **数据访问**：
   - C++可以直接访问底层数据结构，对于某些特定操作（如内存访问、数组遍历等）可能有更好的性能表现。
   - 蓝图对常用操作进行了封装，但对于复杂的数据结构操作，可能需要更多的中间步骤。

3. **热重载与编译优化**：
   - 蓝图的一大优势是支持热重载，这对于开发阶段的迭代非常高效。但在发布版本中，蓝图会被编译成本地代码以提升运行效率。
   - C++代码在编译时有更多的优化选项，可以直接生成高度优化的代码。

4. **网络同步与性能瓶颈**：
   - 如果游戏性能瓶颈不在本地计算而在网络同步或者其他方面，那么选择蓝图还是C++可能对最终运行效率影响不大。

5. **代码质量和优化程度**：
   - 最终运行效率还会受制于开发者如何编写和优化代码，不论使用蓝图还是C++，写出高效的代码才是关键。

综上所述，单纯比较蓝图项目和C++项目打包后的运行效率并无绝对优劣之分，选择哪种开发方式更多取决于项目需求、团队技能和开发效率等因素。在实践中，很多项目会选择蓝图和C++混编的方式来发挥各自优势，复杂的逻辑和性能敏感的部分使用C++实现，而快速原型和可视化逻辑则利用蓝图。
