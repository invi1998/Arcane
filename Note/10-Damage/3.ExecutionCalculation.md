# Execution Calculation

![image-20240417160851829](.\image-20240417160851829.png)

1. **执行计算（Execution Calculation）**：
   - Capture Attributes：执行计算可以捕捉属性（Attributes）。这意味着它可以改变多个属性，而不只是单一的属性。这使得技能效果可以更加复杂和多样化。
   - Can change more than one Attribute：执行计算可以改变多个属性。这使得技能效果可以同时影响多个属性，例如增加生命值和攻击力。
   - Can have programmer logic：执行计算可以包含程序员逻辑。这意味着程序员可以自定义执行计算的过程，以满足特定的需求。
   - No prediction：执行计算不进行预测。这意味着它只能应用于即时（Instant）或周期性（Periodic）的游戏效果。这保证了执行计算的准确性，但同时也意味着它不能用于预测未来的属性变化。
   - Only Instant or Periodic Gameplay Effects：执行计算只适用于即时或周期性的游戏效果。这限制了执行计算的应用场景，但它也确保了执行计算的简单性和效率。
   - Capturing doesn't run PreAttributeChange; any clamping done there must be done again：执行计算不会运行 PreAttributeChange 函数，任何在该函数中进行的限制（Clamping）操作必须在执行计算过程中再次进行。
   - Only executed on the Server from Gameplay Abilities with Local Predicted, Server Initiated, and Server Only：执行计算只在服务器上执行，来自具有本地预测（Local Predicted）、服务器初始化（Server Initiated）和服务器独占（Server Only）特性的游戏能力。
   - From the Target, the value is captured on Effect Application only：对于目标，只有在应用效果时才会捕获值。这确保了执行计算只在实际应用效果时才进行，而不是在创建效果时就进行。
2. **快照（Snapshotting）**：
   - Snapshotting captures the Attribute value when the Gameplay Effect Spec is created：快照捕捉属性值，当游戏效果规范（Spec）创建时。
   - Not snapshotting captures the Attribute value when the Gameplay Effect is applied：非快照捕捉属性值，当游戏效果应用时。
   - From the Target, the value is captured on Effect Application only：对于目标，只有在应用效果时才会捕获值。



# Damage Execution Calculation

![image-20240417162055506](.\image-20240417162055506.png)

这是我们之前的伤害实现方式，很简单的通过传入一个可缩放的固定值。对于伤害计算，我们除了选择Set by Caller，还可以选择自定义计算（Custom Calculation），这会比简单设置一个值要复杂很多。

![image-20240417162251510](.\image-20240417162251510.png)

1：创建一个类，该类基于UGameplayEffectExecutionCalculation基类创建，用于GameplayEffect里的执行计算

```c++

/**
 * 
 */
UCLASS()
class ARCANE_API UExecCalc_Damage : public UGameplayEffectExecutionCalculation
{
	GENERATED_BODY()

public:
	UExecCalc_Damage();

	// 该函数用于计算伤害，
	virtual void Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams, FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const override;
	
};
```

## UGameplayEffectExecutionCalculation

`UGameplayEffectExecutionCalculation` 是虚幻引擎（Unreal Engine）中一个类，用于描述游戏效果（Gameplay Effect）的执行计算。执行计算决定了游戏效果如何在游戏世界中应用，包括捕捉属性、改变属性值、包含程序员逻辑等。

`UGameplayEffectExecutionCalculation` 类提供了以下功能：

- `CaptureAttributes()`：执行计算可以捕捉属性（Attributes），这意味着它可以改变多个属性，而不只是单一的属性。
- `CanChangeMoreThanOneAttribute()`：执行计算可以改变多个属性，这使得技能效果可以更加复杂和多样化。
- `CanHaveProgrammerLogic()`：执行计算可以包含程序员逻辑，这意味着程序员可以自定义执行计算的过程，以满足特定的需求。
- `NoPrediction()`：执行计算不进行预测，这意味着它只能应用于即时（Instant）或周期性（Periodic）的游戏效果。这保证了执行计算的准确性，但同时也意味着它不能用于预测未来的属性变化。
- `OnlyInstantOrPeriodicGameplayEffects()`：执行计算只适用于即时或周期性的游戏效果。这限制了执行计算的应用场景，但它也确保了执行计算的简单性和效率。
- `CapturingDoesntRunPreAttributeChangeAnyClampingDoneThereMustBeDoneAgain()`：执行计算不会运行 PreAttributeChange 函数，任何在该函数中进行的限制（Clamping）操作必须在执行计算过程中再次进行。这确保了属性变化的正确性，但也增加了编程的复杂性。
- `OnlyExecutedOnServerFromGameplayAbilitiesWithLocalPredictedServerInitiatedServerOnly()`：执行计算只在服务器上执行，来自具有本地预测（Local Predicted）、服务器初始化（Server Initiated）和服务器独占（Server Only）特性的游戏能力。这确保了执行计算的正确性和一致性。
- `FromTargetValueCapturedOnEffectApplicationOnly()`：对于目标，只有在应用效果时才会捕获值。这确保了执行计算只在实际应用效果时才进行，而不是在创建效果时就进行。

`UGameplayEffectExecutionCalculation` 类提供了一种灵活的方式来定义游戏效果的执行过程，使游戏开发人员能够创建出复杂多样的技能效果。




# ExecCalcs - Capturing Attributes 属性捕获

```c++
#include "CoreMinimal.h"
#include "GameplayEffectExecutionCalculation.h"
#include "AbilitySystem/AuraAttributeSet.h"
#include "ExecCalc_Damage.generated.h"

// 该结构体用于存储捕获的属性（该结构体作为一个原生结构体，不会用于蓝图）
struct AuraDamageStatics
{
	// 该宏用于声明一个捕获属性的结构体，其中包含了捕获的属性的指针，以及捕获的属性的名称
	DECLARE_ATTRIBUTE_CAPTUREDEF(Armor);		// 护甲
	DECLARE_ATTRIBUTE_CAPTUREDEF(ArmorPenetration);	// 护甲穿透

	AuraDamageStatics()
	{
		// 该函数用于捕获属性
		DEFINE_ATTRIBUTE_CAPTUREDEF(UAuraAttributeSet, Armor, Target, false);	// 捕获目标的护甲属性，不捕获快照
		DEFINE_ATTRIBUTE_CAPTUREDEF(UAuraAttributeSet, ArmorPenetration, Source, false);	// 捕获来源的护甲穿透属性，不捕获快照
	}
};

// 该静态函数将在每次调用时返回一个AuraDamageStatics的实例，返回值每次调用都是相同的
static const AuraDamageStatics& GetAuraDamageStatics()
{
	static AuraDamageStatics AuraStatics;
	return AuraStatics;
}

/**
 * 
 */
UCLASS()
class ARCANE_API UExecCalc_Damage : public UGameplayEffectExecutionCalculation
{
	GENERATED_BODY()

public:
	UExecCalc_Damage();

	// 该函数用于计算伤害，
	virtual void Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams, FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const override;
	
};

```

```c++
#include "AbilitySystem/ExecCalc/ExecCalc_Damage.h"

#include "AbilitySystemComponent.h"

UExecCalc_Damage::UExecCalc_Damage()
{
	RelevantAttributesToCapture.Add(AuraDamageStatics().ArmorDef);	// 捕获护甲
}

void UExecCalc_Damage::Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams,
	FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const
{
	// 获取AbilitySystemComponent
	const UAbilitySystemComponent* SourceASC = ExecutionParams.GetSourceAbilitySystemComponent();
	const UAbilitySystemComponent* TargetASC = ExecutionParams.GetTargetAbilitySystemComponent();

	// 获取Avatar
	const AActor* SourceAvatar = SourceASC ? SourceASC->GetAvatarActor() : nullptr;
	const AActor* TargetAvatar = TargetASC ? TargetASC->GetAvatarActor() : nullptr;

	// 获取GameplayEffect
	const FGameplayEffectSpec& Spec = ExecutionParams.GetOwningSpec();

	const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags();
	const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags();

	FAggregatorEvaluateParameters EvaluationParameters;
	EvaluationParameters.SourceTags = SourceTags;
	EvaluationParameters.TargetTags = TargetTags;

	float Armor = 0.f;

	// 获取属性值
	ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(
		AuraDamageStatics().ArmorDef,
		EvaluationParameters,
		Armor
		);

	Armor = FMath::Max(0.f, Armor);

	float ArmorPenetration = 0.0f;	// 护甲穿透
	ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(
		AuraDamageStatics().ArmorPenetrationDef,
		EvaluationParameters,
		ArmorPenetration
		);

	// 护穿叠过高，也最只能穿透100%的护甲
	ArmorPenetration = FMath::Max(0.f, FMath::Min(Armor, ArmorPenetration));

	FGameplayModifierEvaluatedData DamageData(AuraDamageStatics().ArmorProperty, EGameplayModOp::Additive, -Armor);
	FGameplayModifierEvaluatedData ArmorPenetrationData(AuraDamageStatics().ArmorPenetrationProperty, EGameplayModOp::Additive, ArmorPenetration);

	// 最终伤害 减去护甲
	OutExecutionOutput.AddOutputModifier(
		DamageData
	);

	// 加上护甲穿透
	OutExecutionOutput.AddOutputModifier(
		ArmorPenetrationData
	);

}

```

`DECLARE_ATTRIBUTE_CAPTUREDEF` 和 `DEFINE_ATTRIBUTE_CAPTUREDEF` 是虚幻引擎（Unreal Engine）中用于定义属性捕捉的宏。它们主要用于游戏效果（Gameplay Effect）的执行计算中，用于捕捉属性值并在游戏世界中应用。

`DECLARE_ATTRIBUTE_CAPTUREDEF` 宏用于声明属性捕捉的定义，它通常在类的接口（Interface）部分使用。这个宏声明了一个属性捕捉的结构体类型，该结构体类型包含了属性捕捉的元数据，如属性类型、捕捉方法等。

`DEFINE_ATTRIBUTE_CAPTUREDEF` 宏用于定义属性捕捉的结构体类型，它通常在类的实现（Implementation）部分使用。这个宏定义了属性捕捉的结构体类型，该结构体包含了属性捕捉的具体实现，如属性值的获取、设置等。