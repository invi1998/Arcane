# Execution Calculation

![image-20240417160851829](.\image-20240417160851829.png)

1. **执行计算（Execution Calculation）**：
   - Capture Attributes：执行计算可以捕捉属性（Attributes）。这意味着它可以改变多个属性，而不只是单一的属性。这使得技能效果可以更加复杂和多样化。
   - Can change more than one Attribute：执行计算可以改变多个属性。这使得技能效果可以同时影响多个属性，例如增加生命值和攻击力。
   - Can have programmer logic：执行计算可以包含程序员逻辑。这意味着程序员可以自定义执行计算的过程，以满足特定的需求。
   - No prediction：执行计算不进行预测。这意味着它只能应用于即时（Instant）或周期性（Periodic）的游戏效果。这保证了执行计算的准确性，但同时也意味着它不能用于预测未来的属性变化。
   - Only Instant or Periodic Gameplay Effects：执行计算只适用于即时或周期性的游戏效果。这限制了执行计算的应用场景，但它也确保了执行计算的简单性和效率。
   - Capturing doesn't run PreAttributeChange; any clamping done there must be done again：执行计算不会运行 PreAttributeChange 函数，任何在该函数中进行的限制（Clamping）操作必须在执行计算过程中再次进行。
   - Only executed on the Server from Gameplay Abilities with Local Predicted, Server Initiated, and Server Only：执行计算只在服务器上执行，来自具有本地预测（Local Predicted）、服务器初始化（Server Initiated）和服务器独占（Server Only）特性的游戏能力。
   - From the Target, the value is captured on Effect Application only：对于目标，只有在应用效果时才会捕获值。这确保了执行计算只在实际应用效果时才进行，而不是在创建效果时就进行。
2. **快照（Snapshotting）**：
   - Snapshotting captures the Attribute value when the Gameplay Effect Spec is created：快照捕捉属性值，当游戏效果规范（Spec）创建时。
   - Not snapshotting captures the Attribute value when the Gameplay Effect is applied：非快照捕捉属性值，当游戏效果应用时。
   - From the Target, the value is captured on Effect Application only：对于目标，只有在应用效果时才会捕获值。



# Damage Execution Calculation

![image-20240417162055506](.\image-20240417162055506.png)

这是我们之前的伤害实现方式，很简单的通过传入一个可缩放的固定值。对于伤害计算，我们除了选择Set by Caller，还可以选择自定义计算（Custom Calculation），这会比简单设置一个值要复杂很多。

![image-20240417162251510](.\image-20240417162251510.png)

1：创建一个类，该类基于UGameplayEffectExecutionCalculation基类创建，用于GameplayEffect里的执行计算

```c++

/**
 * 
 */
UCLASS()
class ARCANE_API UExecCalc_Damage : public UGameplayEffectExecutionCalculation
{
	GENERATED_BODY()

public:
	UExecCalc_Damage();

	// 该函数用于计算伤害，
	virtual void Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams, FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const override;
	
};
```

## UGameplayEffectExecutionCalculation

`UGameplayEffectExecutionCalculation` 是虚幻引擎（Unreal Engine）中一个类，用于描述游戏效果（Gameplay Effect）的执行计算。执行计算决定了游戏效果如何在游戏世界中应用，包括捕捉属性、改变属性值、包含程序员逻辑等。

`UGameplayEffectExecutionCalculation` 类提供了以下功能：

- `CaptureAttributes()`：执行计算可以捕捉属性（Attributes），这意味着它可以改变多个属性，而不只是单一的属性。
- `CanChangeMoreThanOneAttribute()`：执行计算可以改变多个属性，这使得技能效果可以更加复杂和多样化。
- `CanHaveProgrammerLogic()`：执行计算可以包含程序员逻辑，这意味着程序员可以自定义执行计算的过程，以满足特定的需求。
- `NoPrediction()`：执行计算不进行预测，这意味着它只能应用于即时（Instant）或周期性（Periodic）的游戏效果。这保证了执行计算的准确性，但同时也意味着它不能用于预测未来的属性变化。
- `OnlyInstantOrPeriodicGameplayEffects()`：执行计算只适用于即时或周期性的游戏效果。这限制了执行计算的应用场景，但它也确保了执行计算的简单性和效率。
- `CapturingDoesntRunPreAttributeChangeAnyClampingDoneThereMustBeDoneAgain()`：执行计算不会运行 PreAttributeChange 函数，任何在该函数中进行的限制（Clamping）操作必须在执行计算过程中再次进行。这确保了属性变化的正确性，但也增加了编程的复杂性。
- `OnlyExecutedOnServerFromGameplayAbilitiesWithLocalPredictedServerInitiatedServerOnly()`：执行计算只在服务器上执行，来自具有本地预测（Local Predicted）、服务器初始化（Server Initiated）和服务器独占（Server Only）特性的游戏能力。这确保了执行计算的正确性和一致性。
- `FromTargetValueCapturedOnEffectApplicationOnly()`：对于目标，只有在应用效果时才会捕获值。这确保了执行计算只在实际应用效果时才进行，而不是在创建效果时就进行。

`UGameplayEffectExecutionCalculation` 类提供了一种灵活的方式来定义游戏效果的执行过程，使游戏开发人员能够创建出复杂多样的技能效果。




# ExecCalcs - Capturing Attributes 属性捕获

```c++
#pragma once

#include "CoreMinimal.h"
#include "GameplayEffectExecutionCalculation.h"
#include "AbilitySystem/AuraAttributeSet.h"
#include "ExecCalc_Damage.generated.h"

// 该结构体用于存储捕获的属性（该结构体作为一个原生结构体，不会用于蓝图）
struct AuraDamageStatics
{
	// 该宏用于声明一个捕获属性的结构体，其中包含了捕获的属性的指针，以及捕获的属性的名称
	DECLARE_ATTRIBUTE_CAPTUREDEF(Armor);		// 护甲
	DECLARE_ATTRIBUTE_CAPTUREDEF(ArmorPenetration);	// 护甲穿透
	DECLARE_ATTRIBUTE_CAPTUREDEF(BlockChance);	// 格挡几率

	AuraDamageStatics()
	{
		// 该函数用于捕获属性
		DEFINE_ATTRIBUTE_CAPTUREDEF(UAuraAttributeSet, Armor, Target, false);	// 捕获目标的护甲属性，不拍快照
		DEFINE_ATTRIBUTE_CAPTUREDEF(UAuraAttributeSet, ArmorPenetration, Source, false);	// 捕获来源的护甲穿透属性，不拍快照
		DEFINE_ATTRIBUTE_CAPTUREDEF(UAuraAttributeSet, BlockChance, Target, false);		// 捕获目标的格挡几率属性，不拍快照
	}
};

// 该静态函数将在每次调用时返回一个AuraDamageStatics的实例，返回值每次调用都是相同的
static const AuraDamageStatics& GetAuraDamageStatics()
{
	static AuraDamageStatics AuraStatics;
	return AuraStatics;
}

/**
 * 
 */
UCLASS()
class ARCANE_API UExecCalc_Damage : public UGameplayEffectExecutionCalculation
{
	GENERATED_BODY()

public:
	UExecCalc_Damage();

	// 该函数用于计算伤害，
	virtual void Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams, FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const override;
	
};

```

```c++
// Copyright INVI1998


#include "AbilitySystem/ExecCalc/ExecCalc_Damage.h"

#include "AbilitySystemComponent.h"
#include "AuraGameplayTags.h"

UExecCalc_Damage::UExecCalc_Damage()
{
	RelevantAttributesToCapture.Add(AuraDamageStatics().ArmorDef);	// 捕获护甲
	RelevantAttributesToCapture.Add(AuraDamageStatics().ArmorPenetrationDef);	// 捕获穿甲
	RelevantAttributesToCapture.Add(AuraDamageStatics().BlockChanceDef);	// 捕获格挡
}

void UExecCalc_Damage::Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams,
	FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const
{
	// 获取AbilitySystemComponent
	const UAbilitySystemComponent* SourceASC = ExecutionParams.GetSourceAbilitySystemComponent();
	const UAbilitySystemComponent* TargetASC = ExecutionParams.GetTargetAbilitySystemComponent();

	// 获取Avatar
	const AActor* SourceAvatar = SourceASC ? SourceASC->GetAvatarActor() : nullptr;
	const AActor* TargetAvatar = TargetASC ? TargetASC->GetAvatarActor() : nullptr;

	// 获取GameplayEffect
	const FGameplayEffectSpec& Spec = ExecutionParams.GetOwningSpec();

	const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags();
	const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags();

	FAggregatorEvaluateParameters EvaluationParameters;
	EvaluationParameters.SourceTags = SourceTags;
	EvaluationParameters.TargetTags = TargetTags;

	// 通过Caller Magnitude（调用者的属性值）获取伤害
	float Damage = Spec.GetSetByCallerMagnitude(FAuraGameplayTags::Get().Damage);
	
	// 捕获格挡(受击者格挡几率)
	float TargetBlockChance = 0.f;
	ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(AuraDamageStatics().BlockChanceDef, EvaluationParameters, TargetBlockChance);
	TargetBlockChance = FMath::Max(0.f, TargetBlockChance);

	// 捕获护甲(受击者护甲)
	float TargetArmor = 0.f;	// 捕获护甲
	ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(AuraDamageStatics().ArmorDef, EvaluationParameters, TargetArmor);
	TargetArmor = FMath::Max(0.f, TargetArmor);

	// 捕获穿甲 (攻击者穿甲) 百分比穿甲
	float SourceArmorPenetration = 0.f;
	ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(AuraDamageStatics().ArmorPenetrationDef, EvaluationParameters, SourceArmorPenetration);
	SourceArmorPenetration = FMath::Max(0.f, SourceArmorPenetration);

	// 判断是否格挡（百分比）
	if (FMath::RandRange(0, 100) <= TargetBlockChance)
	{
		// 伤害减少
		Damage *= 0.5f;
	}

	const float EffectTargetArmor = TargetArmor *= (100 - SourceArmorPenetration * 0.25f) / 100.f;	// 穿甲减少护甲

	// 最终伤害 = 格挡后的伤害 - 护甲 + 穿甲
	Damage = FMath::Max(0.f, Damage * (100 - EffectTargetArmor) / 100.f);

	const FGameplayModifierEvaluatedData EvaluatedData(UAuraAttributeSet::GetIncomingDamageAttribute(), EGameplayModOp::Additive, Damage);
	OutExecutionOutput.AddOutputModifier(EvaluatedData);

}

```

`DECLARE_ATTRIBUTE_CAPTUREDEF` 和 `DEFINE_ATTRIBUTE_CAPTUREDEF` 是虚幻引擎（Unreal Engine）中用于定义属性捕捉的宏。它们主要用于游戏效果（Gameplay Effect）的执行计算中，用于捕捉属性值并在游戏世界中应用。

`DECLARE_ATTRIBUTE_CAPTUREDEF` 宏用于声明属性捕捉的定义，它通常在类的接口（Interface）部分使用。这个宏声明了一个属性捕捉的结构体类型，该结构体类型包含了属性捕捉的元数据，如属性类型、捕捉方法等。

`DEFINE_ATTRIBUTE_CAPTUREDEF` 宏用于定义属性捕捉的结构体类型，它通常在类的实现（Implementation）部分使用。这个宏定义了属性捕捉的结构体类型，该结构体包含了属性捕捉的具体实现，如属性值的获取、设置等。

然后回到我们的GE_Damage（伤害游戏效果）,我们此前是用Modify修饰符来当个值改变伤害，设置伤害，这里我们不用Modify，用自定义计算（Executions），然后指定我们的计算类。

![image-20240417193414357](.\image-20240417193414357.png)

![image-20240417193603866](.\image-20240417193603866.png)