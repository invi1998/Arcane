# Prediction In GAS

![image-20240413125812474](.\image-20240413125812474.png)

GAS（Gameplay Ability System）中的预测设计期望是自动化的，并且能够根据需要进行预测。在GAS中，预测并不是所有情况都需要的，只有在某些特定情况下才需要进行预测。例如，对于一些需要实时响应的游戏元素，如移动、攻击、治疗和造成伤害等，就需要进行预测。而对于一些不需要实时响应的游戏元素，如脚步声等，则不需要进行预测。



![image-20240413130005329](.\image-20240413130005329.png)

GAS（Gameplay Ability System）中的预测功能实现了以下方面的预测：

1. Gameplay Ability Activation：GAS会自动预测游戏能力的激活，这意味着在客户端，玩家可以立即看到游戏能力的效果，而无需等待服务器确认。

2. Triggered Events：GAS会自动预测触发事件，这意味着在客户端，玩家可以立即看到触发事件的效果，而无需等待服务器确认。

3. Gameplay Effect Application：GAS会自动预测游戏效果的应用，包括属性修改器（但不包括执行计算），游戏标签修改，以及来自预测游戏能力的事件。

4. Gameplay Cue Events：GAS会自动预测游戏提示事件，这些事件可以来自预测的游戏能力内部，或者它们自己的事件。

5. Montages：GAS会自动预测蒙太奇，这通常用于动画序列。

6. Movement（UCharacterMovement）：GAS会自动预测移动，这通常用于角色的移动和导航。

GAS不会预测以下方面：

1. Gameplay Effect Removal：GAS不会自动预测游戏效果的移除，这意味着在客户端，玩家可能看到错误的游戏效果，直到服务器确认移除。

2. Gameplay Effect Periodic Effects：GAS不会自动预测游戏效果的周期性效果，这意味着在客户端，玩家可能看到错误的游戏效果，直到服务器确认周期性效果的更新。

需要注意的是，这些预测功能是由GAS自动完成的，开发者无需编写额外的代码来实现这些预测。



![image-20240413130452793](.\image-20240413130452793.png)

GAS（Gameplay Ability System）为了实现Prediction，围绕Prediction Key做了以下事情：

1. 创建和管理Prediction Key：在客户端，每当一个动作需要被预测时，GAS会生成一个新的Prediction Key。这个Prediction Key包含了所有必要的信息，以便在客户端和服务器之间同步动作。

2. 预测动作：GAS使用Prediction Key来预测动作。当一个动作被触发时，GAS会使用Prediction Key来计算动作的结果，并在客户端立即应用这些结果。

3. 同步预测：GAS使用Prediction Key来同步预测。当一个动作被触发时，GAS会使用Prediction Key来计算动作的结果，并将这些结果发送给服务器。服务器会使用这些结果来验证客户端的预测，并在必要时进行修正。

4. 反馈预测：GAS使用Prediction Key来反馈预测。当一个动作被触发时，GAS会使用Prediction Key来计算动作的结果，并将这些结果发送给服务器。服务器会使用这些结果来验证客户端的预测，并在必要时进行修正。如果服务器发现客户端的预测有误，它会将修正后的结果发送回客户端。

在GAS中，Replicate和我们平时接触的变量复制有所不同。在传统的网络编程中，变量复制通常是单向的，即服务器将变量复制给客户端，但客户端无法将变量复制给服务器。这是因为变量复制通常涉及到网络传输，而网络传输通常是单向的。

然而，在GAS中，变量复制并不完全是单向的。虽然GAS中的变量复制仍然是单向的，即服务器将变量复制给客户端，但GAS还提供了一种机制，允许客户端将变量复制给服务器。这种机制被称为“反馈预测”，它允许客户端将预测的结果发送给服务器，供服务器验证和修正。

因此，虽然变量复制在GAS中仍然是单向的，但它不再完全局限于服务器到客户端的方向，而是可以通过反馈预测机制扩展到客户端到服务器的方向。



## Ability Activation

![image-20240413131521432](.\image-20240413131521432.png)

Ability Activation是指在游戏中的技能或能力的激活过程。在游戏开发中，技能或能力的激活通常涉及到以下几个步骤：

1. 触发：技能或能力的激活通常由玩家的操作触发，例如按下某个按键或组合键。触发器可以是各种各样的，包括按键、鼠标点击、触摸屏操作等。

2. 激活：一旦触发器被激活，游戏引擎就会开始处理这个技能或能力的激活过程。这通常包括检查技能或能力是否满足激活条件，例如冷却时间是否已过期、是否有足够的法力值或能量等。

3. 预测：在技能或能力激活的过程中，游戏引擎通常会对技能或能力的效果进行预测。预测通常是在客户端进行的，以提供更流畅的游戏体验。预测的结果通常会在服务器上进行校验，以确保游戏的公平性和一致性。

4. 执行：一旦技能或能力通过了激活条件并进行了预测，游戏引擎就会开始执行技能或能力的效果。这通常包括移动角色、施放魔法、攻击敌人等。

5. 反馈：在技能或能力执行后，游戏引擎通常会向玩家提供反馈，以告知玩家技能或能力是否成功执行。这通常包括视觉效果、声音效果、游戏内消息等。

在游戏开发中，技能或能力的激活是一个非常重要的部分，因为它直接影响到游戏的可玩性和趣味性。因此，游戏开发者通常会花费大量的时间和精力来设计和实现技能或能力的激活过程。

Prediction Window是指在技能或能力激活过程中，游戏引擎用来预测技能或能力效果的时间窗口。在这个时间窗口内，游戏引擎可以根据玩家的操作和游戏状态，预测技能或能力的效果，并在客户端提前渲染出来，以提供更流畅的游戏体验。

Prediction Window的长度通常取决于技能或能力的类型和复杂程度。对于简单的技能或能力，Prediction Window可以设置得较短，因为它们的预测和执行相对简单。而对于复杂的技能或能力，Prediction Window需要设置得较长，以确保预测的准确性。

在游戏开发中，Prediction Window是一个非常重要的概念，因为它可以提高游戏的响应速度和流畅度，使游戏更加有趣和吸引人。但是，Prediction Window也可能会带来一些问题，例如预测错误导致的游戏崩溃或不公平性。因此，游戏开发者需要仔细设计和实现Prediction Window，以确保游戏的稳定性和公平性。



![image-20240413132146126](.\image-20240413132146126.png)

TryActivateAbility是一个函数，用于尝试激活一个技能或能力。以下是TryActivateAbility函数的详细步骤：

1. 客户端调用TryActivateAbility函数，传入一个技能或能力的实例。
2. TryActivateAbility函数创建一个新的FPredictionKey对象，并将其赋值为一个名为"Activation Prediction Key"的新字符串。
3. TryActivateAbility函数继续执行，调用ActivateAbility函数，传入创建的FPredictionKey对象和技能或能力的实例。
4. 在ActivateAbility函数内部，客户端执行一系列操作，例如生成副作用、更新技能或能力的状态等。
5. 在客户端执行完一系列操作后，服务器接收到TryActivateAbility函数的调用，并决定是否激活技能或能力。
6. 如果服务器决定激活技能或能力，则调用ClientActivateAbilitySucceeded函数，通知客户端技能或能力已经激活成功。
7. 如果服务器决定不激活技能或能力，则调用ClientActivateAbilityFailed函数，通知客户端技能或能力激活失败。
8. 客户端接收到服务器的响应后，根据服务器的响应结果，决定是否要撤销副作用或者继续执行副作用。

总之，TryActivateAbility函数主要用于尝试激活一个技能或能力，并在服务器确认后，通知客户端技能或能力已经激活成功或失败。

![image-20240413132600132](.\image-20240413132600132.png)

Gameplay Effect Prediction是一种技术，用于在游戏中预测和应用游戏效果。具体来说，当一个游戏效果被激活时，它会产生一些副作用，如属性修改、游戏标签修改和游戏提示等。这些副作用通常只在客户端应用，但在某些情况下，可能需要在服务器上应用。

为了实现这种功能，UE5使用了一种称为ReplicatedPredictionKey的技术。当一个游戏效果被激活时，它会生成一个预测密钥，并将该密钥与游戏效果相关联。如果客户端有一个有效的预测密钥，并且游戏效果需要预测，那么游戏效果将在客户端应用。

当游戏效果被应用时，它会存储预测密钥。当游戏效果被复制到服务器时，服务器也会得到相同的预测密钥。如果客户端和服务器上的预测密钥相同，那么游戏效果的应用逻辑就不需要在服务器上执行，从而减少了服务器的计算负担。