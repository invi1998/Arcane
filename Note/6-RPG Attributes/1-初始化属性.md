# 从数据表初始化属性

我们此前的对属性值的初始化是在构造函数里完成的，但是，这显然不是首选，也不是业界的规范。这里我介绍另一种初始化方式，从数据表初始化

```c++
/*
 * RPG 主属性（Primary Attributes）
 */
UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category = "Primary Attributes")
FGameplayAttributeData Strength;	// 力量
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Strength)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Agility, Category = "Primary Attributes")
FGameplayAttributeData Agility;		// 敏捷
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Agility)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Intelligence, Category = "Primary Attributes")
FGameplayAttributeData Intelligence;	// 智力
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Intelligence)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Vigor, Category = "Primary Attributes")
FGameplayAttributeData Vigor;		// 活力
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Vigor)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Resilience, Category = "Primary Attributes")
FGameplayAttributeData Resilience;	// 韧性
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Resilience)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数
```

这是我们数据集里的属性成员，为了初始化他们，我们用表格方式，需要先创建一个对应的数据表，表格行类型选择 AttributeMetaData

![image-20240409102929220](.\image-20240409102929220.png) 

![image-20240409103819959](.\image-20240409103819959.png)

然后将DT应用到蓝图上，这样也能成功初始化属性值

![image-20240409104012277](.\image-20240409104012277.png)



# 使用GameEffect初始化属性

在游戏开始使用GameEffect来初始化属性，应该是最规范的做法了。所以，我们在角色基类里，新增一个初始化Attributes的方法，同时，添加一个默认游戏效果类成员，用来初始化属性用

```c++

	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category="Attributes")
	TSubclassOf<UGameplayEffect> DefaultPrimaryGameplayEffectClass;		// 默认主要游戏效果类

	void InitializePrimaryAbilities() const;		// 初始化主要能力

```



```c++
void AAuraCharacterBase::InitializePrimaryAbilities() const
{
	checkf(IsValid(GetAbilitySystemComponent()), TEXT("AbilitySystemComponent is nullptr!"));	// 检查AbilitySystemComponent是否为空
	checkf(DefaultPrimaryGameplayEffectClass, TEXT("DefaultPrimaryGameplayEffectClass is nullptr!"));	// 检查DefaultPrimaryGameplayEffectClass是否为空

	// 1：获取上下文
	const FGameplayEffectContextHandle EffectContext = GetAbilitySystemComponent()->MakeEffectContext();
	// 2：创建效果
	const FGameplayEffectSpecHandle SpecHandle = GetAbilitySystemComponent()->MakeOutgoingSpec(DefaultPrimaryGameplayEffectClass, 1.f, EffectContext);
	// 3：应用效果到目标
	GetAbilitySystemComponent()->ApplyGameplayEffectSpecToTarget(*SpecHandle.Data.Get(), GetAbilitySystemComponent());
}
```

然后在角色的初始化代码中调用它

```c++
void AAuraCharacter::InitAbilityActorInfo()
{
	AAuraPlayerState* AuraPlayerState = GetPlayerState<AAuraPlayerState>();
	check(AuraPlayerState);
	AuraPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(AuraPlayerState, this);	// 初始化技能系统组件
	Cast<UAuraAbilitySystemComponent>(AuraPlayerState->GetAbilitySystemComponent())->AbilityActorInfoSet();	// 设置技能Actor信息
	AbilitySystemComponent = AuraPlayerState->GetAbilitySystemComponent();	// 获取技能系统组件
	AttributeSet = AuraPlayerState->GetAttributeSet();	// 获取属性集

	// 很多人纠结到底在什么情况下应该断言PlayerController*，什么时候只需要判断指针是否为空？
	// 因为我们这个是一个多人游戏，而控制器在客户端只有自己角色的控制器，其他角色的控制器是空的，服务端有所有角色的控制器。
	// 所以控制器这个指针是会存在空的情况的，这是正常的，说明这个控制器不是自己的控制器。
	// 所以这种情况下我们只需要判断指针是否为空就可以了，不需要断言。
	if (AAuraPlayerController* AuraPlayerController = Cast<AAuraPlayerController>(GetController()))
	{
		if (AAuraHUD* AuraHUD = Cast<AAuraHUD>(AuraPlayerController->GetHUD()))
		{
			AuraHUD->InitOverlay(AuraPlayerController, AuraPlayerState, AbilitySystemComponent, AttributeSet);
		}
	}

	InitializePrimaryAbilities();	// 初始化主要能力

}

```

做好这一切后，我们下一步就是去编辑器中，提供一个GameplayEffect，用来初始化Attributes

![image-20240409111125266](.\image-20240409111125266.png)

唯一需要注意的一点是，我们这里对属性的操作方式，选择覆盖，因为我们是初始化属性，这一点切记。

然后回到角色蓝图，将该GE赋值给角色就行

![image-20240409111349753](.\image-20240409111349753.png)



# 基于属性的修改器

到目前为止，我们所有的游戏效果都可以使用功能缩放浮点数作为其修改器来改变属性值的大小，但是，实际上在GE中，还有更多更复杂的修改器使用功场景。

![image-20240409112911590](.\image-20240409112911590.png)

在虚幻引擎 5 (UE5) 中，GameplayEffect 的 Modifier Magnitude 设置项用于定义效果的强度或大小。这个设置项位于Gameplay Effect的Modifiers部分，用于控制效果对目标属性的影响程度。以下是对各个配置项的详细解释和用法：

1. **Magnitude Calculation Type**: 这个选项决定了Modifier Magnitude的计算方式。有以下几种选择：
   - **Attribute Based**: Modifier Magnitude的值基于目标属性的值。例如，你可以设置一个效果为“增加目标属性的10%”。
   - **Fixed Value**: Modifier Magnitude是一个固定的数值，不会随目标属性的变化而变化。例如，你可以设置一个效果为“增加目标属性10点”。
   - **Randomized Fixed Value**: Modifier Magnitude是一个随机的固定数值，可以在一个范围内进行随机取值。例如，你可以设置一个效果为“增加目标属性10到20点之间的一个随机值”。
   - **Randomized Attribute Based**: Modifier Magnitude基于目标属性的随机值，可以在一个范围内进行随机取值。例如，你可以设置一个效果为“增加目标属性的10%到20%之间的一个随机值”。

2. **Coefficient**: 这是一个乘数，用于放大或缩小效果的强度。例如，如果你设置Coefficient为2.0，那么效果的强度将会翻倍。

3. **Pre Multiply Additive Value**: 这是一个在乘以系数之前添加的值。例如，如果你设置Pre Multiply Additive Value为5.0，那么效果的强度将会增加5.0。

4. **Post Multiply Additive Value**: 这是一个在乘以系数之后添加的值。例如，如果你设置Post Multiply Additive Value为5.0，那么效果的强度将会增加5.0。

5. **Backing Attribute**: 这个设置用于记录效果的原始属性值。当你想要恢复目标属性到原来的状态时，可以使用这个设置。例如，如果你设置Backing Attribute为“Health”，那么在效果结束后，目标的健康值将会恢复到效果开始前的值。

6. **Attribute to Capture**: 这个设置用于捕获目标属性的值。例如，如果你设置Attribute to Capture为“Health”，那么在效果期间，每次目标的健康值发生变化时，都会被记录下来。

7. **Snapshot**: 这个设置用于创建一个目标属性的快照。例如，如果你设置Snapshot为“Health”，那么在效果开始时，目标的健康值会被记录下来，作为恢复的目标值。

8. **Attribute Curve**: 这个设置用于定义效果随时间变化的曲线。例如，你可以设置一个曲线，使得效果在开始时较强，然后逐渐减弱。或者，你可以设置一个曲线，使得效果在开始时较弱，然后逐渐增强。

9. **Source Tags Filter**和**Target Tags Filter**: 这两个设置用于限制效果作用的对象。你可以设置一些标签，只有满足这些标签的对象才会受到效果的影响。

10. **Source Tags**和**Target Tags**: 这两个设置用于指定效果作用的对象。你可以设置一些标签，只有带有这些标签的对象才会受到效果的影响。

通过灵活地组合这些设置项，你可以创建出各种复杂的效果，如增加或减少目标属性、根据目标属性的值来调整效果的强度、以及让效果随着时间变化等等。