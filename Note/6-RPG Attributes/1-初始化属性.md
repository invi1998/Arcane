# 从数据表初始化属性

我们此前的对属性值的初始化是在构造函数里完成的，但是，这显然不是首选，也不是业界的规范。这里我介绍另一种初始化方式，从数据表初始化

```c++
/*
 * RPG 主属性（Primary Attributes）
 */
UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Strength, Category = "Primary Attributes")
FGameplayAttributeData Strength;	// 力量
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Strength)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Agility, Category = "Primary Attributes")
FGameplayAttributeData Agility;		// 敏捷
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Agility)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Intelligence, Category = "Primary Attributes")
FGameplayAttributeData Intelligence;	// 智力
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Intelligence)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Vigor, Category = "Primary Attributes")
FGameplayAttributeData Vigor;		// 活力
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Vigor)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Resilience, Category = "Primary Attributes")
FGameplayAttributeData Resilience;	// 韧性
ATTRIBUTE_ACCESSORS(UAuraAttributeSet, Resilience)	// 生成属性的Getter函数，属性的Setter函数，属性的初始化函数
```

这是我们数据集里的属性成员，为了初始化他们，我们用表格方式，需要先创建一个对应的数据表，表格行类型选择 AttributeMetaData

![image-20240409102929220](.\image-20240409102929220.png) 

![image-20240409103819959](.\image-20240409103819959.png)

然后将DT应用到蓝图上，这样也能成功初始化属性值

![image-20240409104012277](.\image-20240409104012277.png)



# 使用GameEffect初始化属性

在游戏开始使用GameEffect来初始化属性，应该是最规范的做法了。所以，我们在角色基类里，新增一个初始化Attributes的方法，同时，添加一个默认游戏效果类成员，用来初始化属性用

```c++

	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category="Attributes")
	TSubclassOf<UGameplayEffect> DefaultPrimaryGameplayEffectClass;		// 默认主要游戏效果类

	void InitializePrimaryAbilities() const;		// 初始化主要能力

```



```c++
void AAuraCharacterBase::InitializePrimaryAbilities() const
{
	checkf(IsValid(GetAbilitySystemComponent()), TEXT("AbilitySystemComponent is nullptr!"));	// 检查AbilitySystemComponent是否为空
	checkf(DefaultPrimaryGameplayEffectClass, TEXT("DefaultPrimaryGameplayEffectClass is nullptr!"));	// 检查DefaultPrimaryGameplayEffectClass是否为空

	// 1：获取上下文
	const FGameplayEffectContextHandle EffectContext = GetAbilitySystemComponent()->MakeEffectContext();
	// 2：创建效果
	const FGameplayEffectSpecHandle SpecHandle = GetAbilitySystemComponent()->MakeOutgoingSpec(DefaultPrimaryGameplayEffectClass, 1.f, EffectContext);
	// 3：应用效果到目标
	GetAbilitySystemComponent()->ApplyGameplayEffectSpecToTarget(*SpecHandle.Data.Get(), GetAbilitySystemComponent());
}
```

然后在角色的初始化代码中调用它

```c++
void AAuraCharacter::InitAbilityActorInfo()
{
	AAuraPlayerState* AuraPlayerState = GetPlayerState<AAuraPlayerState>();
	check(AuraPlayerState);
	AuraPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(AuraPlayerState, this);	// 初始化技能系统组件
	Cast<UAuraAbilitySystemComponent>(AuraPlayerState->GetAbilitySystemComponent())->AbilityActorInfoSet();	// 设置技能Actor信息
	AbilitySystemComponent = AuraPlayerState->GetAbilitySystemComponent();	// 获取技能系统组件
	AttributeSet = AuraPlayerState->GetAttributeSet();	// 获取属性集

	// 很多人纠结到底在什么情况下应该断言PlayerController*，什么时候只需要判断指针是否为空？
	// 因为我们这个是一个多人游戏，而控制器在客户端只有自己角色的控制器，其他角色的控制器是空的，服务端有所有角色的控制器。
	// 所以控制器这个指针是会存在空的情况的，这是正常的，说明这个控制器不是自己的控制器。
	// 所以这种情况下我们只需要判断指针是否为空就可以了，不需要断言。
	if (AAuraPlayerController* AuraPlayerController = Cast<AAuraPlayerController>(GetController()))
	{
		if (AAuraHUD* AuraHUD = Cast<AAuraHUD>(AuraPlayerController->GetHUD()))
		{
			AuraHUD->InitOverlay(AuraPlayerController, AuraPlayerState, AbilitySystemComponent, AttributeSet);
		}
	}

	InitializePrimaryAbilities();	// 初始化主要能力

}

```

做好这一切后，我们下一步就是去编辑器中，提供一个GameplayEffect，用来初始化Attributes

![image-20240409111125266](.\image-20240409111125266.png)

唯一需要注意的一点是，我们这里对属性的操作方式，选择覆盖，因为我们是初始化属性，这一点切记。

然后回到角色蓝图，将该GE赋值给角色就行

![image-20240409111349753](.\image-20240409111349753.png)