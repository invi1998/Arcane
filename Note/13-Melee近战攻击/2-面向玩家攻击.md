# Facing Target

我们之前已经成功激活了近战攻击能力，现在，我们给近战一个播放攻击蒙太奇的节点，这个很简单，但是我们发现一个问题，就是NPC虽然能正常攻击，但是，他的攻击朝向是有问题的，我们需要播放蒙太奇之前，先将模型转向玩家。

这个功能，应该很熟悉，我们之前在做玩家攻击的时候，就利用MotionWarping来实现蒙太奇动画转向。

所以，如法炮制

1：创建蒙太奇

2：给蒙太奇动画添加一个MotionWarping段，设置WarpingTargetName

3：因为是给NPC添加Warping，所以在NPC基类蓝图上，添加一个MotionWarping组件，然后设置名称

4：在NPC基类蓝图中实现UpdateFacingTarget

![image-20240421002750742](.\image-20240421002750742.png)

5：为了方便在蓝图中设置攻击目标和获取目标，我们在NPC接口中新增两个接口函数（蓝图原生事件），该类接口需要子类实现，同时也需要蓝图实现，但是蓝图版本可以覆盖C++版本

```c++

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Enemy Interface")
	void SetCombatTarget(AActor* InCombatTarget);	// 设置攻击目标

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Enemy Interface")
	AActor* GetCombatTarget() const;	// 获取攻击目标
```

然后在NPC基类中，添加一个CombatTarget成员（AActor*类型）用来存储当前NPC的攻击对象，同时重写SetCombatTarget和GetCombatTarget的Implementation版本，用来保存和设置攻击目标

```c++

	UPROPERTY(BlueprintReadWrite, Category = "Combat")
	TObjectPtr<AActor> CombatTarget;	// 攻击目标

	virtual void SetCombatTarget_Implementation(AActor* NewTarget) override;
	virtual AActor* GetCombatTarget_Implementation() const override;
```

6：因为我们现在是设置近战攻击的攻击目标，所以在BTT_Attack中，我们新增一个黑板键选择器用来从行为树中读取攻击目标（也就是行为树中的FollowTarget），然后如果Target合法，就通过Combat提供的ShetCombatTarget接口来设置攻击目标

![image-20240421003836691](.\image-20240421003836691.png)

7：下一步就是在行为树中设置和保存攻击目标了。因为我们的攻击目标就是我们在行为树中的FollowTarget（跟随目标），所以很简单，只需要在Attack节点，将FollowTarget赋给我们BTT_Attack里的选择器就行

![image-20240421004144506](.\image-20240421004144506.png)

8：下一步就是去跟新我们的朝向，我们只需要在GA_MeleeAttack里，在播放蒙太奇节点之前，更新好MotionWarping就行，进一步说，就是调用UpdateFacingTarget。这个也很简单，得益于我们此前已经将UpdateFacingTarget所需要的参数都处理好了，通过CombatInterFace都能得到，所以，如下

![image-20240421004507407](.\image-20240421004507407.png)

这样，就成功的将NPC在攻击之前，让其转向面对玩家进行攻击

![image-20240421004622815](.\image-20240421004622815.png)



