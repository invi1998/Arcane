# GAS in Multyplayer

在多人游戏中，UE5的Gameplay Ability System（GAS）扮演着至关重要的角色，确保各个玩家的角色技能在网络环境下的同步和一致性。以下是在多人游戏中使用GAS的关键要点：

1. **网络同步与预测**: GAS设计时考虑到了网络同步的需求，能够支持服务器权威模式下的技能施放和效果应用。服务器会验证并执行所有的Ability激活请求，然后将结果广播给客户端。为了减少延迟感，客户端通常会对玩家的输入进行预测，即在服务器确认前先行模拟技能的施放和效果，随后再通过服务器回滚或修正不一致的行为。

2. **Gameplay Effects Replication**:
   - 当一个Ability在网络环境中触发时，相关联的Gameplay Effects会被复制到所有客户端。GAS通过Replication机制确保这些效果在网络上的准确传播，包括属性增益、减益、持续伤害等状态的变化。

3. **RepNotify Callbacks**:
   - 使用RepNotify功能，服务器可以通知客户端特定属性或状态的变化，这样客户端可以根据服务器的决定来实时更新本地表现，例如角色的生命值变动、技能冷却状态等。

4. **Ability授权与撤销**:
   - 在多人游戏中，服务器需要控制每个玩家何时获得或失去使用特定技能的能力。GAS提供了机制来追踪和管理每个玩家Controller拥有的Abilities，确保不会出现非法或未授权的Ability使用。

5. **技能冷却同步**:
   - 技能冷却时间在多人游戏中同样需要精确同步。服务器计算和管理Ability冷却，客户端则依据服务器的指示更新用户界面及阻止非法的提前再次施放。

6. **反作弊保护**:
   - GAS可以通过严格的服务器验证来防止作弊行为，比如确保玩家不能随意增加资源（如能量点数）、绕过冷却时间或非法施放未经授予的技能。

7. **游戏逻辑一致性**:
   - GAS支持编写清晰的游戏逻辑，无论是简单的一次性技能施放还是复杂的状态机转换，都能在网络环境下保持一致的执行顺序和结果。

总的来说，UE5的Gameplay Ability System为多人游戏提供了强大的基础架构，使得开发者能够在创建丰富多样的角色技能的同时，确保这些技能在网络环境中的稳定性和公平性。通过合理配置和优化GAS，开发者能够构建出既有趣又具备良好网络性能的多人游戏体验。



## 这与传统的UE里的RPC有什么异同吗

UE5的Gameplay Ability System（GAS）与传统虚幻引擎（UE）中的远程过程调用（RPC）机制有着不同的用途和应用场景，但它们在网络同步和通信方面有一定的协同工作。

**传统UE中的RPC**：

- RPC是一种跨网络通信的技术，允许服务器与客户端之间互相调用函数，实现数据的同步和指令的传输。
- RPC分为Server RPC和Client RPC，分别用于服务器对客户端和客户端对服务器的直接函数调用。
- 在多人游戏中，RPC常用于处理非即时游戏状态的同步，例如通知客户端更新UI，或者客户端请求服务器执行特定操作等。

**UE5的GAS**：
- GAS专注于游戏内的技能、状态和效果的管理，这些往往是直接影响游戏实时动态和平衡性的核心元素。
- GAS在网络同步方面采取的是服务器权威模型，即技能的施放、效果的触发和结算都在服务器上进行，并通过网络同步给客户端。
- GAS中，技能的执行和效果的复制（Replication）是系统级别的，更关注的是实时游戏逻辑的正确执行，包括冷却时间、消耗资源、触发特效、改变角色属性等。

**异同点**：
- 异同点在于，RPC主要用于通用的消息传递和调用，而GAS则专用于游戏内角色技能系统的设计与同步。
- 在多人游戏中，RPC和GAS可以相互补充。例如，使用RPC进行非游戏状态相关操作的同步，而GAS则确保所有与角色能力相关的动作在网络上的准确执行和同步。
- GAS实际上也是建立在UE的网络同步机制基础上的，它内部可能也会使用到RPC或者其他网络通信技术来确保服务器和客户端之间数据的一致性。

综上所述，GAS是针对游戏内角色能力这一特定领域设计的高度抽象化的框架，它在很大程度上封装和优化了网络通信和同步逻辑，减轻了开发者在实现多人游戏中技能同步方面的负担。而传统的RPC则是更底层的网络通信工具，适用于更广泛的应用场景。



## Multiplayer

![image-20240405234809753](.\image-20240405234809753.png)

在UE5中，一些游戏属性和类确实有不同的存在位置，下面列举了一些常见的游戏组件，并说明它们在网络环境下的存在形式：

1. **GameMode**：
   - GameMode类在单人游戏中存在于服务器和客户端。在多人游戏中，服务器端拥有唯一的GameMode实例，客户端上也有一个GameMode实例，但客户端的GameMode更多的是为了同步服务器状态和控制本地玩家行为。
   - 在服务器端，GameMode负责游戏规则的制定、回合开始与结束、玩家重生等全局游戏逻辑。
   - 客户端上的GameMode主要用于同步服务器的设置，并驱动本地游戏规则的表现。

2. **GameState**：
   - GameState类也同时存在于服务器和客户端，但真正的游戏状态数据（如分数、游戏阶段等）是由服务器维护的单一权威实例。
   - 服务器上的GameState记录并更新游戏的全局状态，然后通过网络复制（Replication）将状态同步给所有客户端。
   - 客户端上的GameState接收服务器同步来的状态，并据此更新本地游戏世界的呈现。

3. **PlayerController**：
   - PlayerController通常在每个玩家的客户端都有实例，而且服务器上也为每个玩家创建一个PlayerController实例。
   - 服务器端的PlayerController负责处理玩家输入和执行服务器端的AI逻辑（如果适用）。
   - 客户端的PlayerController负责本地玩家的输入处理、摄像机控制和本地预测。

4. **Pawn/ACharacter** 和 **PlayerState**：
   - Pawn和ACharacter（角色）在网络游戏中同样在服务器和客户端都存在。
   - 服务器端的Pawn/Character实例负责处理游戏逻辑，如移动、交互等，并通过网络复制同步到客户端。
   - 客户端的Pawn/Character实例负责本地预测和渲染。
   - PlayerState保存每个玩家持久化的数据，比如得分、等级等，同样在服务器和客户端都有实例，但数据变更由服务器决定并同步给客户端。

在不同网络架构下：

- **监听服务器（Listen Server）**：
  - 在监听服务器模式下，同一个进程既充当服务器又充当一个客户端，所有游戏组件（GameMode、GameState、PlayerController、Pawn/Character和PlayerState）在本地都存在两个版本，一个是作为服务器的权威版本，另一个是作为客户端的本地副本。

- **专用服务器（Dedicated Server）**：
  - 在专用服务器模式下，服务器上只存在服务器侧的游戏组件实例，负责维护游戏的逻辑和状态，而客户端只存在客户端侧的游戏组件实例，负责本地渲染和输入处理。专用服务器模式下，服务器和客户端的责任划分更为明确，服务器专注于游戏逻辑，客户端专注于用户体验。  

总结来说，大多数游戏组件在UE5的多人游戏中都会在服务器和客户端两边都存在，但实际的数据和逻辑处理根据组件的性质和网络架构的不同，会在服务器或客户端进行相应的操作和同步。



## Replication是双向的吗

在虚幻引擎（Unreal Engine，包括UE5）中，**Replication（复制）不是双向的，而是单向的，且是从服务器到客户端的**。服务器上的游戏逻辑和状态变化会被复制到所有连接的客户端，确保所有玩家看到的世界状态一致。这是因为服务器是游戏逻辑的权威来源，以防止客户端篡改游戏状态导致的不公平现象。

客户端不能直接将变化复制回服务器，但客户端可以通过以下方式向服务器发送信息和请求：

1. **远程过程调用（RPCs）**：
   - 客户端可以发起客户端到服务器（Client-to-Server）的RPC调用，请求服务器执行某个函数并将结果返回给客户端。这是一种从客户端向服务器发送信息和请求服务器执行动作的方式。

2. **输入转发**：
   - 客户端可以将玩家的输入信息发送到服务器，服务器接收到输入后，基于这些输入更新游戏状态，并将更新后的状态复制回所有客户端。

3. **Actor组件的网络功能**：
   - 客户端可以触发特定的网络事件，如网络通知（RepNotify）或网络代理（NetProxy）函数，这些函数在服务器上执行并产生相应的游戏逻辑变化。

总之，虽然Replication本身是单向的，但客户端可以通过各种网络通信机制间接地影响服务器的状态，而服务器对这些请求的处理结果会通过Replication同步到所有客户端。