# 前景提要

> 为什么UE5提供的俯视图游戏示例中，我们开启多人模式，只有服务端的角色能正常点击移动到目标位置，而客户端的点击后只会稍微动一下然后就停下来，只能鼠标按住才能正常移动到鼠标位置（提示一下，这是因为这个示例项目它角色的移动方式不是采用MoveComponet组件，而是采用UAIBLueprintHelperLibrary::SimpLeMoveToLocation()来做的移动)

现在我们有输入和可以用来响应这些输入的回调函数，我们可以开始实现我们的功能了。

但是另外，我们还可以为我们的角色实现其他功能。

由于这是一个自上而下的项目，我们应该考虑的一个重要的游戏机制是点击移动。

这是许多自上而下游戏的常见特点，我们有一个独特的机会来找出如何在我们的游戏中实现这一点。

现在碰巧 Unreal Engine 提供了一个顶视角模板项目。

这为我们提供了一个很好的示例，展示了如何实现基本的顶视角。

在这个项目中，我们有点击移动的功能。

如果我点击地面，角色将移动到我点击的位置，如果我点击并按住，角色将跟随我的鼠标光标移动。

所以这是一个相当不错的基本点击移动，但是自上而下的模板实现点击移动有一个重要的限制。

我们可以通过将玩家数量更改为两个，并将网络模式从独立模式更改为其他选项之一，例如作为监听服务器或作为客户端，来快速发现这个限制。

如果我选择其中一个选项并按下立即播放，我们将在多人游戏中有两个角色。

现在，如果我点击并释放，我的角色将不会移动到我点击的位置。

但是，如果我点击并按住，它将正常工作。

现在我选择了作为客户端进行播放，这意味着这两个都是客户端。

如果我在主视口点击并释放，角色将不会移动。

它会移动一点，但当我释放鼠标按钮时，它停止移动。

但是，如果我按住它，一切都正常。

Okay. 好的。

现在，如果我将其更改为作为监听服务器播放，并按下播放按钮，那么我的一个角色将成为主机。

大窗口中的那个角色。

小窗口中的那个是客户端。

现在客户端可以点击并释放，但没有任何反应。

但是，如果我在大窗口中点击并释放，那么我就会得到那种好的自动运行行为。

如果我在两个窗口中显示它，你会看到我可以点击并释放，服务器角色会自动奔跑。

在多人游戏中它是有效的，但是如果我在客户端上点击并释放，它就不起作用。

那为什么会这样呢？有点令人失望的是，自上而下的项目在开箱即用时并没有提供完全可用的点击移动行为，但我们可以通过查看代码来找出原因。

这是自上而下的模板项目，移动设置在自上而下的玩家控制器中，自上而下的玩家控制器绑定了一些回调函数到输入动作，使用了增强输入。

我们有一个设置目标点击动作，并且有多个函数绑定到它。

我们有一个用于开始、触发、完成和取消的回调函数。

现在对于开始和全部，我们只有停止移动。

所以它在每一帧都会调用设置目标触发的函数。

只要按住输入键，我们就开始做事情。

当我们开始点击鼠标左键的那一帧，我们只会得到这个停止移动的调用。

那么这是做什么的呢？好吧，我们将在分析这里的代码时找出原因。

所以在设置时，每一帧都会触发目标触发器。

只要按住输入，您会看到我们有这个成员变量。

它是一个名为跟随时间的浮点数，它获取增量秒并将其添加到跟随时间中。

换句话说，我们有一个随着每帧增加的 Delta 时间的运行时间。

然后它创建一个命中结果，创建一个名为 hit successful 的本地布尔值并将其设置为 false，然后获取手指下的命中结果。

如果 B 是触摸为 true，这是用于移动设备的，否则它只获取光标下的命中结果并填充该命中结果。

现在，如果有成功的命中，它会获取该命中结果并缓存该位置。

所以无论我们点击哪里，如果在光标下获得了一个成功的命中结果，我们就将该世界位置存储在这个缓存的目标向量中。

现在，在存储了该位置之后，我们可以看到评论会随着鼠标指针或触摸移动到获取棋子的位置。

只要它不是空指针，它会通过获取缓存的目标位置并获取受控棋子的角色位置来计算一个方向。

如果我们对这两个向量进行减法运算，我们就会得到一个从受控棋子指向缓存目标位置的向量。

然后调用 get safe normal。

所以我们有一个指向我们想要跑的方向的归一化向量。

然后我们调用 add movement input，传入该方向。

现在这个被每帧调用。

只要调用这个函数，我们就在这里调用添加移动输入。

只要按住输入，这就被称为长按，并且添加移动输入会通过 Pawn 的移动组件移动 Pawn。

对吗？我们可以右键点击并转到添加移动组件的定义。

正如我们所见，它会获取分配给该 Pawn 的任何移动组件，并使用它来添加移动。

现在关于移动组件的酷炫之处在于它们已经内置了复制功能。

这就是为什么如果我们按住鼠标光标，我们会得到复制的移动。

我们可以在客户端按住鼠标光标，服务器会看到这个移动。

只是为了再次向您展示，这是客户端。

如果我点击并按住，你会发现移动看起来很好。

它很流畅，一切都正常，但是自动运行有问题。

如果我点击并释放，自动运行不起作用，但在服务器上可以点击并释放，自动运行起作用。

所以在这种情况下肯定有一些不同的处理方式。

好吧，我们在设置目标释放时，就像我们在设置输入组件中看到的那样，这个函数与我们的输入动作绑定，完成触发事件。

这意味着当我们释放输入时，这个回调函数将被执行。

现在我们看到评论说如果是短按，并且我们检查了跟随时间并查看它是否小于短按阈值。

所以有一段时间我们希望考虑为短按，因为在这个功能的最后我们看到我们重置了跟随时间。

所以当我们释放鼠标按钮时，跟随时间将被重置为零。

但在此之前，我们要检查一下。

这是一个短按。

否则，我们已经按住鼠标光标一段时间了，这意味着我们一直在执行这里的功能，并设置了触发目标，基本上是通过添加移动输入来移动角色。

我们看到这在多人游戏中完全正常，但如果是短按，我们会以不同的方式处理移动。

它使用 UI，蓝图助手库调用简单的移动到位置，传入缓存的目标位置。

并且它还处理在缓存的目标位置生成一个系统，一个尼亚加拉系统。

而这个系统就是我们在这里看到的带有这些小箭头的系统。

That's a Niagara system. 那是一个尼亚加拉系统。

当我们调用简单的移动到位置时，我们就在这里生成它。

现在简单的移动到位置是一个 AI 函数。

它在 AI 蓝图助手库中。

And I moved. 而且我搬家了。

这两个函数不是设计用于客户端调用的。

它们是为了在 AI 角色的服务器上调用而设计的。

所以如果你有一个由服务器控制的 AI 角色，你可以使用简单的移动到位置，并且如果该 AI 角色的移动被复制，它将复制到所有客户端，没有问题。

但对于一个由人控制的角色，这是行不通的。

它在本地工作，但没有内置的多人复制功能。

它不像在移动组件上调用添加移动输入那样。

这里内置了各种延迟补偿。

它具有预测功能，我们可以称之为客户端，并且我们将立即看到我们的角色移动，服务器将通过移动组件接收到该信息。

这一切都非常好和顺畅，但很简单。

移动到位置不会做到这一点。

这不会起作用。

所以我们不能使用简单的移动到位置。

如果我们只是想点击一下，让角色自动移动到一个位置，并期望在多人游戏中能正常工作，那就太可惜了。

这真是令人遗憾，因为当我们使用这个功能时，我们可以获得一些有趣的路径规划能力。

假设我想点击这个柱子的另一侧。

嗯，如果我在服务器上这样做，我们使用的是简单的移动到位置功能，所以我可以点击它，它会绕过柱子。

它会找到绕过柱子的路径。

It's using pathfinding. 它使用了路径规划。

这是因为有一个导航网格边界体。

如果我们按下 P 键，我们可以看到它是必需的。

我移动到类型函数来工作，但是，很遗憾的是，我们不能只是使用它并期望在多人游戏中正常工作，就像我们在顶部向下的模板中看到的那样。

我们可以点击，但没有什么特别的事情发生。

我们必须点击并按住以在多人游戏中移动我们的客户端。

所以这是顶部向下模板的一个限制。

这意味着我们不能只使用顶部向下模板的代码。

我们必须做一些比那更复杂的事情。

所以从这个分析中我们学到的是，顶部向下模板使用简单的移动到位置。

如果是短按，它只在多人游戏中不起作用，只有服务器上或托管玩家上的 AI 控制角色。

现在，如果按键一直按下，则会使用 add movement input。

在这种情况下，我们已经看到它在多人游戏中起作用，并且需要持续的输入。

换句话说，我们每一帧都调用 add movement input，传入一个移动方向。

Now this works locally. 现在这在本地工作。

如果我们在客户端上看到服务器上的移动，并且确实复制到所有其他客户端，即使我们没有测试过那种情况，它也可以与多个其他客户端一起工作。

因此，对于阿尔古斯项目，我们将如何兼顾两全其美呢？我们将如何实现点击移动行为，即点击并进行短暂按压？换句话说，点击并立即释放，然后看到我们的角色移动到该位置。

即使利用路径规划，绕过障碍物等等。

这就是我们想要做的。

![image-20240411231149311](.\image-20240411231149311.png)

嗯，我们知道我们必须使用添加移动输入。

我们必须每帧执行此操作。

只要我们的角色在移动，我们就必须不断传入正确的方向并添加移动。

如果我们能够做到这一点，输入在多人游戏中将起作用。

所以我们每一帧都需要一个方向。

那么让我们思考一下我们如何做到这一点。

我们有我们的角色和我们的鼠标光标。

现在我们的棋子有一个位置，我们的鼠标光标有一个世界位置。

如果我们得到了它下面的命中结果。

现在，如果我们有角色的位置和鼠标光标的命中结果位置，只要没有障碍物，这两点之间形成一条直线。

所以，将这两个位置计算出一个方向是相当容易的，然后只要我们需要移动，我们就可以在每一帧调用添加移动输入的函数。

这将使我们的角色朝正确的方向移动，并且在多人游戏中有效。

现在这是一个相当简单的情况，但在多人游戏中会有一些复杂情况。

我们可能会有一些阻碍物。

假设我们有一个柱子或者其他障碍物，对吧？而我们角色和鼠标光标所在位置之间的直线会穿过这个障碍物。

现在我们不能只是朝那个方向移动。

我们的角色会撞到墙上，但仍然会继续试图穿过墙壁移动，这看起来会很糟糕。

我们需要某种寻路方式。

我们需要一种方法来找到能绕过柱子的点，从而为我们创建一条路径。

现在，我们可以使用一些函数来生成这种类型的路径。

这不是问题，但这也可能导致一些不太理想的行为。

你看，我们可以很容易地计算出从角色当前位置到路径上下一个点的方向。

这是一条直线，我们可以沿着这条直线移动角色，直到它到达第二个点，此时方向会改变。

一旦我们到达第二个点，我们就改变角色的方向，并继续调用添加移动输入，直到我们到达下一个点，此时方向再次改变。

现在，这可能导致方向突然改变，这可能不太理想。

考虑这样一种情况，我们从正上方俯视角色，可以看到挡路的障碍物的顶部，我们生成一条路径来绕过它。

现在我们的方向将从角色的位置指向路径中的第二个点，这是一条直线。

一旦我们达到这一点，方向的变化就会突然发生。

我们甚至可能看到它突然出现。

一旦我们达到下一个点，我们的方向变化再次突然，这可能不太理想。

如果我们的路径能够平滑曲线就好了。

Now this is possible. 现在这是可能的。

我们可以根据我们生成的一系列点创建样条线，样条线会自动平滑并呈现出一个漂亮的圆曲线。

现在，如果我们可以从某些路径点生成样条线，那么我们就可以在任何点上获得样条线的前进方向，并且它总是切线于该样条线曲线。

当我们沿着样条线移动时，这个方向可以很平滑。

我们永远不会有突然的变化。

当我们沿着样条线移动时，我们总是会有一个平滑、连续的方向变化。

所以，如果我们能够生成一个路径来移动，这是一个很好的解决方案。

我们可以创建一个样条曲线，它将是一个漂亮的平滑曲线，使我们能够以平滑的方式绕过障碍物。

这就是我想在这个游戏中采用的点击移动机制的方法。
