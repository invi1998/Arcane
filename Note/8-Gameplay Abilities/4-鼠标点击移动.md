# UNavigationSystemV1::FindPathToLocationSynchronously 

在 Unreal Engine 5 (UE5) 中，UNavigationSystemV1::FindPathToLocationSynchronously 是一个 API 函数，用于在导航网格上查找一条从起点到目标点的路径。这个函数主要用于游戏中的寻路功能，例如让游戏角色沿着路径移动到目标位置。

以下是 UNavigationSystemV1::FindPathToLocationSynchronously 函数的详细说明：

- **类名**：UNavigationSystemV1
- **函数名**：FindPathToLocationSynchronously
- **参数**：
  - `StartLocation`：路径的起点位置。
  - `TargetLocation`：路径的目标位置。
  - `NavAreaMask`：用于限制路径搜索范围的导航区域掩码。
  - `PathResult`：用于存储路径结果的结构体指针。

这个函数会同步地在导航网格上查找一条从起点到目标点的路径，并将路径的结果存储在 PathResult 结构体中。这个函数通常在游戏逻辑中用于控制角色或 AI 移动到目标位置。

以下是一个使用 UNavigationSystemV1::FindPathToLocationSynchronously 函数的示例代码：

```cpp
// 假设 StartLocation 和 TargetLocation 已经被设置好
FNavigationPath PathResult;
bool bSuccess = UNavigationSystemV1::FindPathToLocationSynchronously(StartLocation, TargetLocation, 0xFFFFFFFF, PathResult);
if (bSuccess && PathResult.Path.IsValid())
{
    // 路径找到了，可以开始沿着路径移动角色
    // ...
}
else
{
    // 路径找不到，可能是因为目标位置不可达
    // ...
}
```

在这个示例中，我们首先创建一个 FNavigationPath 结构体实例 PathResult，然后调用 UNavigationSystemV1::FindPathToLocationSynchronously 函数，将起点 StartLocation、目标点 TargetLocation、导航区域掩码（这里使用 0xFFFFFFFF 表示所有导航区域）和路径结果 PathResult 作为参数传入。如果函数返回 true，则表示路径找到了，我们可以开始沿着路径移动角色。如果函数返回 false，则表示路径找不到，可能是因为目标位置不可达。



使用该函数需要再构建文件中将 ·NavigationSystem· 模块包含到项目中。

同时，使用该功能，还需要视线在场景中绘制好网络导航区域

![image-20240412015755323](.\image-20240412015755323.png)

拖拽一个 `导航网格体边界体积`到场景中，然后，按下P键，将其缩放到场景大小

![image-20240412020134195](.\image-20240412020134195.png)

当我们在场景中发下一些带碰撞体积的物体时，系统会自动剔除这部分导航体积

![image-20240412021521188](.\image-20240412021521188.png)

对于我们的自动寻路，我们需要如下这些变量控制。

```c++

	/*
	 * 寻路避障
	 */
	FVector CashedDestination = FVector::ZeroVector;	// 缓存的目标位置

	float FollowTime = 0.1f;	// 跟随时间

	float ShortPressThreshold = 0.5f;	// 短按阈值

	bool bAutoRunning = false;	// 是否自动寻路

	bool bTargeting = false;	// 是否在瞄准

	UPROPERTY(EditDefaultsOnly)
	float AutoRunAcceptanceRadius = 50.0f;	// 自动寻路接受半径

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<USplineComponent> Spline;	// 样条曲线组件
```

如果是玩家鼠标长按，我们直接用Actor的自动寻路就行，传入起始点和终点（因为这是每帧执行，所以直接进行向量移动，每帧角色的朝向都能实时计算）

```c++

void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
{
	// GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT("AbilityInputTagHeld: %s"), *InputTag.ToString()));

	if (!InputTag.MatchesTagExact(FAuraGameplayTags::Get().InputTag_RightMouseButton))	// 如果输入标签不匹配自动寻路标签（右键点地板）
	{
		if (GetASC())
		{
			GetASC()->AbilityInputTagHeld(InputTag);	// 调用能力系统组件的技能输入标签按住函数
		}

		return;
	}

	// 表明右键点击角色也能触发技能
	if (bTargeting)
	{
		if (GetASC())
		{
			GetASC()->AbilityInputTagHeld(InputTag);	// 调用能力系统组件的技能输入标签按住函数
		}
	}
	else
	{
		// 如果当前没有命中Actor，那么自动寻路
		FollowTime += GetWorld()->GetDeltaSeconds();	// 跟随时间增加

		// 前往目标位置，所以这里需要获取鼠标光标下的碰撞结果
		FHitResult CursorHitResult;	// 创建一个碰撞结果
		if (GetHitResultUnderCursor(ECC_Visibility, false, CursorHitResult))	// 获取鼠标光标下的碰撞结果，ECC_Visibility表示只检测可见性通道，false表示不检测复杂碰撞，CursorHitResult是碰撞结果
		{
			CashedDestination = CursorHitResult.ImpactPoint;	// 缓存目标位置,ImpactPoint是碰撞点
		}

		// 如果按下时间超过阈值，那么自动寻路
		if (APawn* ControlledPawn = GetPawn<APawn>())
		{
			ControlledPawn->AddMovementInput(
				(CashedDestination - ControlledPawn->GetActorLocation()).GetSafeNormal(),	// 添加移动输入，这里是前往目标位置，所以方向是目标位置减去当前位置,GetSafeNormal是获取单位向量
				1.f);	// 添加移动输入，这里是前往目标位置，所以方向是目标位置减去当前位置，速度是1
		}
	}
}
```

但是如果是点按，如果还采用这种方式，就会出现避障的问题，如果两点之间如果有碰撞体，那么角色会卡主，而且，按照常理，在遇到碰撞物的时候，应该会改变一下自身的朝向，避障式的运动。

所以这时候，如果还用这种两点间的向量位移就显得不够用了。

所以这里用样条进行。

```c++
void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
{
	// GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, FString::Printf(TEXT("AbilityInputTagReleased: %s"), *InputTag.ToString()));

	if (!InputTag.MatchesTagExact(FAuraGameplayTags::Get().InputTag_RightMouseButton))	// 如果输入标签不匹配自动寻路标签（右键点地板）
	{
		if (GetASC())
		{
			GetASC()->AbilityInputTagReleased(InputTag);
		}

		return;
	}

	if (bTargeting)
	{
		if (GetASC())
		{
			GetASC()->AbilityInputTagReleased(InputTag);
		}
	}
	else
	{
		APawn* ControlledPawn = GetPawn<APawn>();	// 获取控制的Pawn
		// 判断当前是短按还是长按
		if (FollowTime <= ShortPressThreshold && ControlledPawn)
		{
			// 点按（短按）时，通过寻路避障到目标位置
			// // 寻找路径到目标位置
			if (UNavigationPath* NavPath = UNavigationSystemV1::FindPathToLocationSynchronously(this, ControlledPawn->GetActorLocation(), CashedDestination))	// 如果路径有效
			{
				// 生成样条曲线
				Spline->ClearSplinePoints();	// 清空样条曲线点
				for (const auto& PathPoint : NavPath->PathPoints)	// 遍历路径点
				{
					Spline->AddSplinePoint(PathPoint, ESplineCoordinateSpace::World);	// 添加样条曲线点
					// 绘制调试线
					DrawDebugSphere(GetWorld(), PathPoint, 10.f, 12, FColor::Green, false, 5.1f);	// 绘制调试球体
				}
				bAutoRunning = true;	// 设置为自动寻路
				Spline->UpdateSpline();	// 更新样条曲线
			}
		}

		FollowTime = 0.f;	// 重置跟随时间
		bTargeting = false;	// 取消瞄准
	}
}

```

![image-20240412021647699](.\image-20240412021647699.png)

现在，我们已经得到了路径点，下一步就是计算得到距离角色最近的样条点，然后移动，然后移除这个点，直到走完所有路径点，完成寻路移动。所以，我们新增一个函数专门做这个计算，同时，记住，这个方法需要没帧调用

```c++
void AAuraPlayerController::AutoRun()
{
	if (bAutoRunning)
	{
		APawn* ContrlPawn = GetPawn();	// 获取控制的Pawn
		if (!ContrlPawn) return;

		const FVector PawnLocation = ContrlPawn->GetActorLocation();	// 获取Pawn的位置
		const FVector LocationOnSpline = Spline->FindLocationClosestToWorldLocation(PawnLocation, ESplineCoordinateSpace::World);	// 获取样条曲线上离Pawn最近的点的位置
		const FVector DirectionOnSpline = Spline->FindDirectionClosestToWorldLocation(PawnLocation, ESplineCoordinateSpace::World);	// 获取样条曲线上离Pawn最近的点的方向

		ContrlPawn->AddMovementInput(DirectionOnSpline, 1.f);	// 添加移动输入，这里是沿着样条曲线移动，所以方向是样条曲线上离Pawn最近的点的方向，速度是1

		// 判断是否到达我们的目标位置，并且在我们自动奔跑的半径阈值下
		const float Distance = FVector::Dist(PawnLocation, LocationOnSpline);	// 计算Pawn位置和样条曲线上离Pawn最近的点的位置的距离
		if (Distance <= AutoRunAcceptanceRadius)	// 如果距离小于100
		{
			bAutoRunning = false;	// 取消自动寻路
		}

	}
}

```



## 允许客户端导航

至此，我们应该可以成功在服务端点击导航到目标点，但是如果换到客户端，会发现，还是出现短按不寻路的问题，这需要我们在项目设置这，打开允许客户端导航

![image-20240412023914822](.\image-20240412023914822.png)